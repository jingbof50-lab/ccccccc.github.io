local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/FakeAngles/PasteWare/refs/heads/main/linoralib.lua"))()
local ThemeManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/FakeAngles/PasteWare/refs/heads/main/manage2.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/FakeAngles/PasteWare/refs/heads/main/manager.lua"))()
local Window = Library:CreateWindow({
    Title = 'rts.solutions',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})
local Tabs = {
    Main = Window:AddTab('核心功能'),
    ['Exploits'] = Window:AddTab('攻击功能'),
    ['Visuals'] = Window:AddTab('视觉效果'),
    ['UI Settings'] = Window:AddTab('界面设置'),
}
local aimbox = Tabs.Main:AddLeftGroupbox("瞄准锁定")
local velbox = Tabs.Main:AddRightGroupbox("位置偏移")
aimbox:AddToggle("aimLock_Enabled", {
    Text = "启用/禁用瞄准锁定",
    Default = false,
    Tooltip = "开启或关闭瞄准锁定功能。",
    Callback = function(value)
        aimLockEnabled = value
        if not aimLockEnabled then
            lockEnabled = false
            isLockedOn = false
            targetPlayer = nil
        end
    end
})
aimbox:AddToggle("aim_Enabled", {
    Text = "瞄准锁定快捷键",
    Default = false,
    Tooltip = "开启或关闭瞄准锁定。",
    Callback = function(value)
        lockEnabled = value
        if not lockEnabled then
            isLockedOn = false
            targetPlayer = nil
        end
    end,
}):AddKeyPicker("aim_Enabled_KeyPicker", {
    Default = "Q", 
    SyncToggleState = true,
    Mode = "Toggle","Hold",
    Text = "瞄准锁定按键",
    Tooltip = "用于切换瞄准锁定的按键",
    Callback = function()
        toggleLockOnPlayer()
    end,
})
aimbox:AddSlider("Smoothing", {
    Text = "镜头平滑度",
    Default = 0.1,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Tooltip = "调整镜头移动的平滑程度。",
    Callback = function(value)
        smoothingFactor = value
    end,
})
aimbox:AddSlider("Prediction", {
    Text = "预判系数",
    Default = 0.0,
    Min = 0,
    Max = 2,
    Rounding = 2,
    Tooltip = "调整对目标移动的预判程度。",
    Callback = function(value)
        predictionFactor = value
    end,
})
aimbox:AddDropdown("BodyParts", {
    Values = {"头部", "上躯干", "右上臂", "左上腿", "右上腿", "左上臂"},
    Default = "头部",
    Multi = false,
    Text = "目标身体部位",
    Tooltip = "选择要锁定的身体部位。",
    Callback = function(value)
        -- 映射汉化值到原始部位名
        local partMap = {
            ["头部"] = "Head",
            ["上躯干"] = "UpperTorso",
            ["右上臂"] = "RightUpperArm",
            ["左上腿"] = "LeftUpperLeg",
            ["右上腿"] = "RightUpperLeg",
            ["左上臂"] = "LeftUpperArm"
        }
        bodyPartSelected = partMap[value] or "Head"
    end,
})
local reverseResolveIntensity = 5
getgenv().Desync = false
getgenv().DesyncEnabled = false  
game:GetService("RunService").Heartbeat:Connect(function()
    if getgenv().DesyncEnabled then  
        if getgenv().Desync then
            local player = game.Players.LocalPlayer
            local character = player.Character
            if not character then return end 
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if not humanoidRootPart then return end
            local originalVelocity = humanoidRootPart.Velocity
            local randomOffset = Vector3.new(
                math.random(-1, 1) * reverseResolveIntensity * 1000,
                math.random(-1, 1) * reverseResolveIntensity * 1000,
                math.random(-1, 1) * reverseResolveIntensity * 1000
            )
            humanoidRootPart.Velocity = randomOffset
            humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.Angles(
                0,
                math.random(-1, 1) * reverseResolveIntensity * 0.001,
                0
            )
            game:GetService("RunService").RenderStepped:Wait()
            humanoidRootPart.Velocity = originalVelocity
        end
    end
end)
velbox:AddToggle("desyncMasterEnabled", {
    Text = "启用位置偏移",
    Default = false,
    Tooltip = "开启或关闭整个位置偏移系统。",
    Callback = function(value)
        getgenv().DesyncEnabled = value  
    end
})
velbox:AddToggle("desyncEnabled", {
    Text = "位置偏移快捷键",
    Default = false,
    Tooltip = "开启或关闭反向解析位置偏移。",
    Callback = function(value)
        getgenv().Desync = value
    end
}):AddKeyPicker("desyncToggleKey", {
    Default = "V", 
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "位置偏移切换按键",
    Tooltip = "用于开启/关闭速度偏移的按键。",
    Callback = function(value)
        getgenv().Desync = value
    end
})
velbox:AddSlider("ReverseResolveIntensity", {
    Text = "速度强度",
    Default = 5,
    Min = 1,
    Max = 10,
    Rounding = 0,
    Tooltip = "调整反向解析效果的强度。",
    Callback = function(value)
        reverseResolveIntensity = value
    end
})
local antiLockEnabled = false
local resolverIntensity = 1.0
local resolverMethod = "Recalculate"
RunService.RenderStepped:Connect(function()
    if aimLockEnabled and isLockedOn and targetPlayer and targetPlayer.Character then
        local partName = getBodyPart(targetPlayer.Character, bodyPartSelected)
        local part = targetPlayer.Character:FindFirstChild(partName)
        if part and targetPlayer.Character:FindFirstChildOfClass("Humanoid").Health > 0 then
            local predictedPosition = part.Position + (part.AssemblyLinearVelocity * predictionFactor)
            if antiLockEnabled then
                if resolverMethod == "Recalculate" then
                    predictedPosition = predictedPosition + (part.AssemblyLinearVelocity * resolverIntensity)
                elseif resolverMethod == "Randomize" then
                    predictedPosition = predictedPosition + Vector3.new(
                        math.random() * resolverIntensity - (resolverIntensity / 2),
                        math.random() * resolverIntensity - (resolverIntensity / 2),
                        math.random() * resolverIntensity - (resolverIntensity / 2)
                    )
                elseif resolverMethod == "Invert" then
                    predictedPosition = predictedPosition - (part.AssemblyLinearVelocity * resolverIntensity * 2)
                end
            end
            local currentCameraPosition = Camera.CFrame.Position
            Camera.CFrame = CFrame.new(currentCameraPosition, predictedPosition) * CFrame.new(0, 0, smoothingFactor)
        else
            isLockedOn = false
            targetPlayer = nil
        end
    end
end)
aimbox:AddToggle("antiLock_Enabled", {
    Text = "启用反锁定解析",
    Default = false,
    Tooltip = "开启或关闭反锁定解析功能。",
    Callback = function(value)
        antiLockEnabled = value
    end,
})
aimbox:AddSlider("ResolverIntensity", {
    Text = "解析强度",
    Default = 1.0,
    Min = 0,
    Max = 5,
    Rounding = 2,
    Tooltip = "调整反锁定解析的强度。",
    Callback = function(value)
        resolverIntensity = value
    end,
})
aimbox:AddDropdown("ResolverMethods", {
    Values = {"重新计算", "随机偏移", "反向偏移"},
    Default = "重新计算", 
    Multi = false,
    Text = "解析方式",
    Tooltip = "选择反锁定解析使用的方式。",
    Callback = function(value)
        -- 映射汉化值到原始方法名
        local methodMap = {
            ["重新计算"] = "Recalculate",
            ["随机偏移"] = "Randomize",
            ["反向偏移"] = "Invert"
        }
        resolverMethod = methodMap[value] or "Recalculate"
    end,
})
Library:SetWatermarkVisibility(true)
local FrameTimer = tick()
local FrameCounter = 0;
local FPS = 60;
local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    FrameCounter += 1;
    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter;
        FrameTimer = tick();
        FrameCounter = 0;
    end;
    Library:SetWatermark(('rts solutions | %s 帧率 | %s 毫秒'):format(
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
    ));
end);
Library.KeybindFrame.Visible = true;
Library:OnUnload(function()
    WatermarkConnection:Disconnect()
    print('已卸载!')
    Library.Unloaded = true
end)
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('菜单')
MenuGroup:AddButton('卸载', function() Library:Unload() end)
MenuGroup:AddLabel('菜单快捷键'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = '菜单按键' })
Library.ToggleKeybind = Options.MenuKeybind
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local targetStrafe = Tabs.Main:AddLeftGroupbox("目标环绕")
local strafeEnabled = false
local teamCheck = false
local strafeAllowed = true
local strafeSpeed, strafeRadius = 50, 5
local strafeMode, targetPlayer = "Horizontal", nil
local originalCameraMode = nil
local function getClosestPlayer()
    local closest, shortestDist = nil, math.huge
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if not teamCheck or (player.Team ~= LocalPlayer.Team) then
                local dist = (LocalPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
                if dist < shortestDist then
                    closest, shortestDist = player, dist
                end
            end
        end
    end
    return closest and closest.Character and closest.Character:FindFirstChild("HumanoidRootPart") and closest.Character or nil
end
local function startTargetStrafe()
    if not strafeAllowed then return end
    targetPlayer = getClosestPlayer()
    if targetPlayer and targetPlayer.Parent then
        originalCameraMode = LocalPlayer.CameraMode
        LocalPlayer.CameraMode = Enum.CameraMode.Classic
        local targetPos = targetPlayer.HumanoidRootPart.Position
        LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(targetPos))
        Camera.CameraSubject = targetPlayer:FindFirstChild("Humanoid")
    end
end
local function strafeAroundTarget()
    if not (strafeAllowed and strafeEnabled and targetPlayer and targetPlayer:FindFirstChild("HumanoidRootPart")) then return end
    local targetPos = targetPlayer.HumanoidRootPart.Position
    local angle = tick() * (strafeSpeed / 10)
    local offset = strafeMode == "Horizontal"
        and Vector3.new(math.cos(angle) * strafeRadius, 0, math.sin(angle) * strafeRadius)
        or Vector3.new(math.cos(angle) * strafeRadius, strafeRadius, math.sin(angle) * strafeRadius)
    LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(targetPos + offset))
    LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(LocalPlayer.Character.HumanoidRootPart.Position, targetPos)
end
local function stopTargetStrafe()
    LocalPlayer.CameraMode = originalCameraMode or Enum.CameraMode.Classic
    Camera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
    strafeEnabled, targetPlayer = false, nil
end
targetStrafe:AddToggle("strafeControlToggle", {
    Text = "启用/禁用",
    Default = true,
    Tooltip = "开启或关闭目标环绕功能的使用权限。",
    Callback = function(value)
        strafeAllowed = value
        if not strafeAllowed and strafeEnabled then
            stopTargetStrafe()
        end
    end
})
targetStrafe:AddToggle("strafeToggle", {
    Text = "启用目标环绕",
    Default = false,
    Tooltip = "开启或关闭目标环绕功能。",
    Callback = function(value)
        if strafeAllowed then
            strafeEnabled = value
            if strafeEnabled then startTargetStrafe() else stopTargetStrafe() end
        end
    end
}):AddKeyPicker("strafeToggleKey", {
    Default = "L",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "目标环绕切换按键",
    Tooltip = "用于切换目标环绕的按键",
    Callback = function(value)
        if strafeAllowed then
            strafeEnabled = value
            if strafeEnabled then startTargetStrafe() else stopTargetStrafe() end
        end
    end
})
targetStrafe:AddToggle("teamCheckToggle", {
    Text = "队伍检测",
    Default = false,
    Tooltip = "仅对敌方队伍玩家进行环绕。",
    Callback = function(value)
        teamCheck = value
    end
})
targetStrafe:AddDropdown("strafeModeDropdown", {
    AllowNull = false,
    Text = "目标环绕模式",
    Default = "水平",
    Values = {"水平", "垂直"},
    Tooltip = "选择环绕移动的模式。",
    Callback = function(value) 
        strafeMode = value == "水平" and "Horizontal" or "UP" 
    end
})
targetStrafe:AddSlider("strafeRadiusSlider", {
    Text = "环绕半径",
    Default = 5,
    Min = 1,
    Max = 20,
    Rounding = 1,
    Tooltip = "设置环绕目标移动的半径。",
    Callback = function(value)
        strafeRadius = value
    end
})
targetStrafe:AddSlider("strafeSpeedSlider", {
    Text = "环绕速度",
    Default = 50,
    Min = 10,
    Max = 200,
    Rounding = 1,
    Tooltip = "设置环绕目标移动的速度。",
    Callback = function(value)
        strafeSpeed = value
    end
})
RunService.RenderStepped:Connect(function()
    pcall(strafeAroundTarget)
end)
game:GetService("RunService").RenderStepped:Connect(function()
    if strafeEnabled and strafeAllowed then strafeAroundTarget() end
end)
local frabox = Tabs.Main:AddRightGroupbox("移动功能")
local localPlayer = game:GetService("Players").LocalPlayer
local Cmultiplier = 1  
local isSpeedActive = false
local isFlyActive = false
local isNoClipActive = false
local isFunctionalityEnabled = true  
local flySpeed = 1
local camera = workspace.CurrentCamera
local humanoid = nil
frabox:AddToggle("functionalityEnabled", {
    Text = "启用/禁用移动功能",
    Default = true,
    Tooltip = "开启或关闭移动类功能。",
    Callback = function(value)
        isFunctionalityEnabled = value
    end
})
frabox:AddToggle("speedEnabled", {
    Text = "加速切换",
    Default = false,
    Tooltip = "使角色快速移动。",
    Callback = function(value)
        isSpeedActive = value
    end
}):AddKeyPicker("speedToggleKey", {
    Default = "C",  
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "加速切换按键",
    Tooltip = "CFrame加速快捷键。",
    Callback = function(value)
        isSpeedActive = value
    end
})
frabox:AddSlider("cframespeed", {
    Text = "CFrame倍率",
    Default = 1,
    Min = 1,
    Max = 666,
    Rounding = 1,
    Tooltip = "CFrame移动速度倍率。",
    Callback = function(value)
        Cmultiplier = value
    end,
})
frabox:AddToggle("flyEnabled", {
    Text = "飞行切换",
    Default = false,
    Tooltip = "切换CFrame飞行功能。",
    Callback = function(value)
        isFlyActive = value
    end
}):AddKeyPicker("flyToggleKey", {
    Default = "F",  
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "飞行切换按键",
    Tooltip = "CFrame飞行快捷键。",
    Callback = function(value)
        isFlyActive = value
    end
})
frabox:AddSlider("flySpeed", {
    Text = "飞行速度",
    Default = 1,
    Min = 1,
    Max = 666,
    Rounding = 1,
    Tooltip = "CFrame飞行速度。",
    Callback = function(value)
        flySpeed = value
    end,
})
frabox:AddToggle("noClipEnabled", {
    Text = "穿墙切换",
    Default = false,
    Tooltip = "开启或关闭穿墙功能。",
    Callback = function(value)
        isNoClipActive = value
    end
}):AddKeyPicker("noClipToggleKey", {
    Default = "N",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "穿墙切换按键",
    Tooltip = "用于切换穿墙功能的快捷键。",
    Callback = function(value)
        isNoClipActive = value
    end
})
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LPlayer = Players.LocalPlayer
local KillAllBox = Tabs['Exploits']:AddLeftGroupbox("全部击杀")
local enemyList = {}
local SelectedEnemies = {}
local LoopKill = false
local KillMode = "Select"
local KillType = "KILL"
local function UpdateEnemyList()
    enemyList = {}
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LPlayer and plr.Team ~= LPlayer.Team then
            table.insert(enemyList, plr.Name)
        end
    end
    Options.EnemySelect:SetValues(enemyList)
end
local function KillPlayer(plr)
    if plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character:FindFirstChild("Head") then
        ReplicatedStorage.RemoteEvents.DamageEvent:FireServer(plr.Character.Humanoid, 41, plr.Character.Head)
    end
end
local function ExplodePlayer(plr)
    if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
        local pos = plr.Character.HumanoidRootPart.Position
        ReplicatedStorage.LocalEvents.ExplodeEvent:Fire(pos, 99, 800, 700)
    end
end
KillAllBox:AddDropdown("EnemySelect", {
    Values = enemyList,
    Multi = true,
    Default = {},
    Text = "选择敌人",
}):OnChanged(function(values)
    SelectedEnemies = values
end)
KillAllBox:AddDropdown("KillMode", {
    Values = {"选择目标", "全部目标"},
    Default = "选择目标",
    Text = "目标模式",
}):OnChanged(function(val)
    KillMode = val == "选择目标" and "Select" or "ALL"
end)
KillAllBox:AddDropdown("KillType", {
    Values = {"直接击杀", "爆炸击杀"},
    Default = "直接击杀",
    Text = "击杀方式",
}):OnChanged(function(val)
    KillType = val == "直接击杀" and "KILL" or "EXPLODE"
end)
KillAllBox:AddToggle("LoopKill", {Text = "循环击杀", Default = false}):OnChanged(function(val)
    LoopKill = val
end)
KillAllBox:AddButton("击杀", function()
    if KillMode == "Select" and next(SelectedEnemies) then
        for name in pairs(SelectedEnemies) do
            local plr = Players:FindFirstChild(name)
            if plr then
                if KillType == "KILL" then
                    KillPlayer(plr)
                elseif KillType == "EXPLODE" then
                    ExplodePlayer(plr)
                end
            end
        end
    elseif KillMode == "ALL" then
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LPlayer and plr.Team ~= LPlayer.Team then
                if KillType == "KILL" then
                    KillPlayer(plr)
                elseif KillType == "EXPLODE" then
                    ExplodePlayer(plr)
                end
            end
        end
    end
end)
task.spawn(function()
    while task.wait(0.3) do
        if LoopKill then
            if KillMode == "ALL" then
                for _, plr in ipairs(Players:GetPlayers()) do
                    if plr ~= LPlayer and plr.Team ~= LPlayer.Team then
                        if KillType == "KILL" then
                            KillPlayer(plr)
                        elseif KillType == "EXPLODE" then
                            ExplodePlayer(plr)
                        end
                    end
                end
            elseif KillMode == "Select" and next(SelectedEnemies) then
                for name in pairs(SelectedEnemies) do
                    local plr = Players:FindFirstChild(name)
                    if plr then
                        if KillType == "KILL" then
                            KillPlayer(plr)
                        elseif KillType == "EXPLODE" then
                            ExplodePlayer(plr)
                        end
                    end
                end
            end
        end
    end
end)
Players.PlayerAdded:Connect(UpdateEnemyList)
Players.PlayerRemoving:Connect(UpdateEnemyList)
UpdateEnemyList()
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local ExplodeBox = Tabs['Exploits']:AddRightGroupbox("点击爆炸")
local Enabled = false
local ClickMode = "CLICK"
local ExplodeDelay = 0.3
local ExplosionsCount = 1
local ExplodeRadius = 30
local ExplodePower = 80
local ExplodePressure = 18
ExplodeBox:AddToggle("ExplodeClickEnable", {
    Text = "启用",
    Default = false,
}):OnChanged(function(val)
    Enabled = val
end)
ExplodeBox:AddDropdown("ExplodeClickMode", {
    Values = {"单次点击", "循环点击"},
    Default = "单次点击",
    Text = "模式",
}):OnChanged(function(val)
    ClickMode = val == "单次点击" and "CLICK" or "LOOP"
end)
ExplodeBox:AddSlider("ExplodeDelay", {
    Text = "爆炸延迟",
    Default = 0.3,
    Min = 0.05,
    Max = 1,
    Rounding = 2,
    Compact = false,
}):OnChanged(function(val)
    ExplodeDelay = val
end)
ExplodeBox:AddSlider("ExplosionsCountSlider", {
    Text = "爆炸次数",
    Default = ExplosionsCount,
    Min = 1,
    Max = 50,
    Rounding = 1,
}):OnChanged(function(val)
    ExplosionsCount = val
end)
ExplodeBox:AddSlider("ExplodeRadiusSlider", {
    Text = "爆炸半径",
    Default = ExplodeRadius,
    Min = 1,
    Max = 99,
    Rounding = 1,
}):OnChanged(function(val)
    ExplodeRadius = val
end)
ExplodeBox:AddSlider("ExplodePowerSlider", {
    Text = "爆炸威力",
    Default = ExplodePower,
    Min = 1,
    Max = 1500,
    Rounding = 1,
}):OnChanged(function(val)
    ExplodePower = val
end)
ExplodeBox:AddSlider("ExplodePressureSlider", {
    Text = "爆炸压力",
    Default = ExplodePressure,
    Min = 1,
    Max = 1500,
    Rounding = 1,
}):OnChanged(function(val)
    ExplodePressure = val
end)
local function ExplodeAt(pos)
    for i = 1, ExplosionsCount do
        ReplicatedStorage.LocalEvents.ExplodeEvent:Fire(pos, ExplodeRadius, ExplodePower, ExplodePressure)
    end
end
local MouseDown = false
UserInputService.InputBegan:Connect(function(input)
    if Enabled and input.UserInputType == Enum.UserInputType.MouseButton1 then
        MouseDown = true
        if ClickMode == "CLICK" then
            local pos = Mouse.Hit.Position
            ExplodeAt(pos)
        elseif ClickMode == "LOOP" then
            spawn(function()
                while MouseDown and Enabled do
                    local pos = Mouse.Hit.Position
                    ExplodeAt(pos)
                    task.wait(ExplodeDelay)
                end
            end)
        end
    end
end)
UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        MouseDown = false
    end
end)
local VisualsEx = Tabs["Visuals"]:AddLeftGroupbox("透视ESP")
if not _G.ExunysESPLoaded then
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Exunys/Exunys-ESP/main/src/ESP.lua"))()
    _G.ExunysESPLoaded = true
end
local ESP = getgenv().ExunysDeveloperESP
ESP.Settings.Enabled = false
local queuedToggles = {
    NameTag = false,
    Box = false,
    Tracer = false,
    HeadDot = false,
    Chams = false,
    HealthBar = false,
    Crosshair = false
}
local function applyQueuedToggles()
    ESP.Properties.ESP.DisplayName = queuedToggles.NameTag
    ESP.Properties.Box.Enabled = queuedToggles.Box
    ESP.Properties.Tracer.Enabled = queuedToggles.Tracer
    ESP.Properties.HeadDot.Enabled = queuedToggles.HeadDot
    ESP.Properties.HealthBar.Enabled = queuedToggles.HealthBar
end
local function setESP(name, value)
    queuedToggles[name] = value
    if ESP.Settings.Enabled then
        applyQueuedToggles()
    end
end
VisualsEx:AddToggle("espEnabled", {
    Text = "启用透视ESP",
    Default = false,
    Callback = function(value)
        if value and not ESP.Loaded then
            ESP:Load()
        end
        ESP.Settings.Enabled = value
        applyQueuedToggles()
    end
})
VisualsEx:AddToggle("teamCheck", {
    Text = "队伍检测",
    Default = false,
    Callback = function(value)
        ESP.Settings.TeamCheck = value
    end
})
local espElements = {"Box", "Tracer", "HeadDot", "HealthBar"}
local espCNames = {"方框", "射线", "头部圆点", "血条"}
for i, name in pairs(espElements) do
    VisualsEx:AddToggle(name:lower().."Enabled", {
        Text = espCNames[i],
        Default = false,
        Callback = function(value)
            setESP(name, value)
        end
    })
end
